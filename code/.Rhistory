#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_oc_source2 = case_when(is.na(derived_opponent_consolidated) ~ NA,
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_oc_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_oc_source2 = case_when(is.na(derived_opponent_consolidated) ~ NA,
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_oc_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
# derived_oc_source2 = case_when(is.na(derived_opponent_consolidated) ~ NA,
#                                id == "2" ~ "trla_more",
#                                is.na(derived_opponent_consolidated.x) ~ "trla_more",
#                                TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_oc_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
# derived_oc_source2 = case_when(is.na(derived_opponent_consolidated) ~ NA,
#                                id == "2" ~ "trla_more",
#                                is.na(derived_opponent_consolidated.x) ~ "trla_more",
#                                TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE)
#count_AP_states.y = ifelse(derived_oc_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_source2 = case_when(is.na(derived_opponent_consolidated) ~ "NA",
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE)
#count_AP_states.y = ifelse(derived_oc_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_source2 = case_when(is.na(derived_opponent_consolidated) ~ "NA",
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_oc_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_source2 = case_when(is.na(derived_opponent_consolidated) ~ "NA",
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
View(trla_more)
## orig data
trla_orig = read_excel(sprintf("%s/raw/Adverse_Parties_FW_TRLA.xlsx", DATA_DIR)) %>%
mutate(`Intake Date` = ymd(`Intake Date`))
##DROPBOX WORKAROUND -- DELETE LATER!
trla_orig <- read_excel("../../raw_workaround/Adverse_Parties_FW_TRLA.xlsx") %>%
mutate(`Intake Date` = ymd(`Intake Date`))
##DROPBOX WORKAROUND -- DELETE LATER!
trla_more = read_excel("../../raw_workaround/master consol - redacted 2.xls") %>%
select(-c("closed","date_close"))
#clean column names in original
clean_1 = gsub("\\s+", "_", tolower(trimws(colnames(trla_orig))))
clean_2 = gsub("\\#", "number", clean_1)
clean_3  = gsub("(?!\\_)[[:punct:]]", "", clean_2, perl = TRUE)
colnames(trla_orig) = clean_3
#Rename trla_more columns to match orig
trla_more <- trla_more %>%
rename(case_number = fileno, legal_problem_code = problem, case_disposition = appsts, intake_date = date_intrv, derived_opponent_consolidated = opponent)
## focus on consolidating opponent columns
#If multiple are present you’d want to separate out.
#So, if ind AP is missing, use Lead AP. You have to decide if a “count” is tied to an individual client or to a group case.
#If Lead AP is missing, that is fine, use individual case AP.
#If both are present, you could separate out into two cases for the first occurrence? Or for each depending on how you’ve decided to count.
trla_orig = trla_orig %>%
mutate(derived_opponent_consolidated = case_when(!is.na(adverse_party_organization) ~ adverse_party_organization,
is.na(adverse_party_organization) & !is.na(lead_case_ap_organization) ~ lead_case_ap_organization,
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
!is.na(adverse_party_name) ~ adverse_party_name,
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
is.na(adverse_party_name) & !is.na(lead_case_ap_name) ~ lead_case_ap_name,
TRUE ~ NA_character_),
derived_opponent_source = case_when(!is.na(adverse_party_organization) ~ "AP org",
is.na(adverse_party_organization) & !is.na(lead_case_ap_organization) ~ "Lead AP org",
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
!is.na(adverse_party_name) ~ "AP name",
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
is.na(adverse_party_name) & !is.na(lead_case_ap_name) ~ "Lead AP name",
TRUE ~ "Missing all"),
derived_opponent_state = (case_when(!is.na(ap_state) ~ ap_state,
is.na(ap_state) ~ lead_case_ap_name,
TRUE ~ NA_character_
)),
derived_opponent_city = (case_when(!is.na(ap_city) ~ ap_city,
is.na(ap_city) ~ lead_case_ap_city,
TRUE ~ NA_character_
)),
derived_is_notemp = case_when(grepl("Social Security Administration|Department of Labor|Workforce|Department|Dept|U.S. Immigration and Customs Enforcement|United States Customs and Border Protection|United States Environmental Protection Agency|United States Immigration and Naturalization Service|United States of America|Texas Attorney General|Texas Employment Commission|US Citizenship And Immigration Services|
Texas Unemployment Commission|workforce", derived_opponent_consolidated) ~ TRUE,
TRUE ~  FALSE)) %>%
select(-c("date_closed", "date_of_rejection","date_opened"))
trla_more <- trla_more %>%
mutate(missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE))
#Create flags for 'in more' & 'missing AP' in either or both
#Filter out earlier data
trla_orig2 <- trla_orig %>%
group_by(case_number) %>%
mutate(in_more = ifelse(case_number %in% trla_more$case_number, TRUE, FALSE)) %>%
ungroup() %>%
mutate(missing_AP = ifelse(is.na(derived_opponent_consolidated), TRUE, FALSE)) %>%
filter(intake_date >= ymd("2014-01-01"))
#See a count of various combinations of missing AP in orig (1) and more (2)
missing_combos <- trla_orig2 %>%
distinct(case_number,.keep_all = TRUE) %>%
bind_rows(trla_more, .id = "id") %>%
select("case_number","id","missing_AP") %>%
pivot_wider(id_cols = "case_number", names_from = "id", values_from = "missing_AP") %>%
group_by(`1`,`2`) %>%
summarise(count = n()) %>%
ungroup()
print(sprintf("There are %s case numbers across both datasets with no AP in either set. There are %s case numbers in trla_orig with a match in trla_more. There are %s case numbers in trla_more but not in trla_orig. There are %s cases with missing AP in trla_orig before merging.",
missing_combos %>%
filter((`1` & `2`) | (`1` & is.na(`2`)) | (`2` & is.na(`1`))) %>%
summarise(sum(count)),
missing_combos %>%
filter((`1` &!`2`)) %>%
summarise(sum(count)),
missing_combos %>%
filter(is.na(`1`)) %>%
summarise(sum(count)),
trla_orig2 %>%
filter(missing_AP) %>%
summarise(length(missing_AP))
))
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_source2 = case_when(is.na(derived_opponent_consolidated) ~ "NA",
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
trla_merge2 <- trla_merge %>%
separate_rows(opstate.y, sep = ",") %>%
mutate(derived_opponent_state = case_when(is.na(opstate.x) ~ opstate.y,
TRUE ~ opstate.x)) %>%
select(intake_date.x, derived_opponent_consolidated_2, derived_opponent_state, )
trla_merge2 <- trla_merge %>%
separate_rows(opstate.y, sep = ",") %>%
mutate(derived_opponent_state = case_when(is.na(opstate.x) ~ opstate.y,
TRUE ~ opstate.x)) %>%
select(intake_date.x, derived_opponent_consolidated, derived_opponent_state, derived_opponent_city)
trla_merge2 <- trla_merge %>%
separate_rows(opstate.y, sep = ",") %>%
mutate(derived_opponent_state = case_when(is.na(opstate.x) ~ opstate.y,
TRUE ~ opstate.x)) %>%
select(c("intake_date.x", "derived_opponent_consolidated", "derived_opponent_state", "derived_opponent_city", "missing_AP", "count_AP_states.y", "derived_is_notemp"))
trla_merge2 <- trla_merge %>%
separate_rows(opstate.y, sep = ",") %>%
mutate(derived_opponent_state = case_when(is.na(opstate.x) ~ opstate.y,
TRUE ~ opstate.x)) %>%
select(c("intake_date.x", "derived_opponent_consolidated", "derived_opponent_state", "derived_opponent_city", "missing_AP", "count_AP_states.y", "derived_is_notemp")) %>%
filter(!derived_is_notemp & !missing_AP)
##DROPBOX WORKAROUND -- DELETE LATER!
trla_orig <- read_excel("../../raw_workaround/Adverse_Parties_FW_TRLA.xlsx") %>%
mutate(`Intake Date` = ymd(`Intake Date`))
library(tidyverse)
library(stringr)
library(fastLink)
library(readr)
library(data.table)
library(readxl)
library(here)
library(lubridate)
## Path to data
RUN_FROM_CONSOLE = FALSE
if(RUN_FROM_CONSOLE){
args <- commandArgs(TRUE)
DATA_DIR = args[1]
} else{
DATA_DIR = "~/Dropbox/qss20_finalproj_rawdata/summerwork"
}
##DROPBOX WORKAROUND -- DELETE LATER!
trla_orig <- read_excel("../../raw_workaround/Adverse_Parties_FW_TRLA.xlsx") %>%
mutate(`Intake Date` = ymd(`Intake Date`))
##DROPBOX WORKAROUND -- DELETE LATER!
trla_more = read_excel("../../raw_workaround/master consol - redacted 2.xls") %>%
select(-c("closed","date_close"))
#clean column names in original
clean_1 = gsub("\\s+", "_", tolower(trimws(colnames(trla_orig))))
clean_2 = gsub("\\#", "number", clean_1)
clean_3  = gsub("(?!\\_)[[:punct:]]", "", clean_2, perl = TRUE)
colnames(trla_orig) = clean_3
#Rename trla_more columns to match orig
trla_more <- trla_more %>%
rename(case_number = fileno, legal_problem_code = problem, case_disposition = appsts, intake_date = date_intrv, derived_opponent_consolidated = opponent)
sprintf("Columns in original data pull: %s", paste(colnames(trla_orig), collapse = ";"))
sprintf("Columns in updated data pull: %s", paste(colnames(trla_more), collapse = ";"))
sprintf("There are %s unique case numbers, %s unique case id/lead case ids, and %s rows in original dataset",
length(unique(trla_orig$case_number)),
length(unique(trla_orig$caseidlead_case_number)),
nrow(trla_orig))
sprintf("There are %s unique case numbers and %s rows in original dataset",
length(unique(trla_more$case_number)),
nrow(trla_more))
## focus on consolidating opponent columns
#If multiple are present you’d want to separate out.
#So, if ind AP is missing, use Lead AP. You have to decide if a “count” is tied to an individual client or to a group case.
#If Lead AP is missing, that is fine, use individual case AP.
#If both are present, you could separate out into two cases for the first occurrence? Or for each depending on how you’ve decided to count.
trla_orig = trla_orig %>%
mutate(derived_opponent_consolidated = case_when(!is.na(adverse_party_organization) ~ adverse_party_organization,
is.na(adverse_party_organization) & !is.na(lead_case_ap_organization) ~ lead_case_ap_organization,
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
!is.na(adverse_party_name) ~ adverse_party_name,
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
is.na(adverse_party_name) & !is.na(lead_case_ap_name) ~ lead_case_ap_name,
TRUE ~ NA_character_),
derived_opponent_source = case_when(!is.na(adverse_party_organization) ~ "AP org",
is.na(adverse_party_organization) & !is.na(lead_case_ap_organization) ~ "Lead AP org",
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
!is.na(adverse_party_name) ~ "AP name",
is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
is.na(adverse_party_name) & !is.na(lead_case_ap_name) ~ "Lead AP name",
TRUE ~ "Missing all"),
derived_opponent_state = (case_when(!is.na(ap_state) ~ ap_state,
is.na(ap_state) ~ lead_case_ap_name,
TRUE ~ NA_character_
)),
derived_opponent_city = (case_when(!is.na(ap_city) ~ ap_city,
is.na(ap_city) ~ lead_case_ap_city,
TRUE ~ NA_character_
)),
derived_is_notemp = case_when(grepl("Social Security Administration|Department of Labor|Workforce|Department|Dept|U.S. Immigration and Customs Enforcement|United States Customs and Border Protection|United States Environmental Protection Agency|United States Immigration and Naturalization Service|United States of America|Texas Attorney General|Texas Employment Commission|US Citizenship And Immigration Services|
Texas Unemployment Commission|workforce", derived_opponent_consolidated) ~ TRUE,
TRUE ~  FALSE)) %>%
select(-c("date_closed", "date_of_rejection","date_opened"))
trla_more <- trla_more %>%
mutate(missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE))
#Create flags for 'in more' & 'missing AP' in either or both
#Filter out earlier data
trla_orig2 <- trla_orig %>%
group_by(case_number) %>%
mutate(in_more = ifelse(case_number %in% trla_more$case_number, TRUE, FALSE)) %>%
ungroup() %>%
mutate(missing_AP = ifelse(is.na(derived_opponent_consolidated), TRUE, FALSE)) %>%
filter(intake_date >= ymd("2014-01-01"))
#See a count of various combinations of missing AP in orig (1) and more (2)
missing_combos <- trla_orig2 %>%
distinct(case_number,.keep_all = TRUE) %>%
bind_rows(trla_more, .id = "id") %>%
select("case_number","id","missing_AP") %>%
pivot_wider(id_cols = "case_number", names_from = "id", values_from = "missing_AP") %>%
group_by(`1`,`2`) %>%
summarise(count = n()) %>%
ungroup()
print(sprintf("There are %s case numbers across both datasets with no AP in either set. There are %s case numbers in trla_orig with a match in trla_more. There are %s case numbers in trla_more but not in trla_orig. There are %s cases with missing AP in trla_orig before merging.",
missing_combos %>%
filter((`1` & `2`) | (`1` & is.na(`2`)) | (`2` & is.na(`1`))) %>%
summarise(sum(count)),
missing_combos %>%
filter((`1` &!`2`)) %>%
summarise(sum(count)),
missing_combos %>%
filter(is.na(`1`)) %>%
summarise(sum(count)),
trla_orig2 %>%
filter(missing_AP) %>%
summarise(length(missing_AP))
))
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_source2 = case_when(is.na(derived_opponent_consolidated) ~ "NA",
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
View(trla_more_unique)
#Follow proposed logic to join the datasets
#Additional logic -- case number matches, present in orig & present in more, but diff AP
#really not sure how to do this without a clear separator for the trla_more opponent data
#just eyeballing it, does not seem like a major issue
trla_more_unique <- trla_more %>%
anti_join(trla_orig2, by = c("case_number")) %>%
filter(intake_date >= ymd("2014-01-01"))
trla_merge <- trla_orig2 %>%
#If trla_more has distinct case numbers...
#Add rows of trla_more with case numbers that do not show up in trla_orig
bind_rows(trla_more_unique, .id = "id") %>%
#If case number matches across sets and opp is missing, sub 'more'
#Join with matching case numbers in trla_more to fill in missing opponent info
left_join(trla_more, by = "case_number") %>%
mutate(
derived_opponent_consolidated = case_when(!is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.x,
is.na(derived_opponent_consolidated.x) ~ derived_opponent_consolidated.y),
#note source of AP
derived_source2 = case_when(is.na(derived_opponent_consolidated) ~ "NA",
id == "2" ~ "trla_more",
is.na(derived_opponent_consolidated.x) ~ "trla_more",
TRUE ~ "trla_orig"),
#for recalculating missing APs
missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE),
count_AP_states.y = ifelse(derived_source2 == "trla_more", str_count(opstate.y, ",") + 1,NA)
)
#Checking the additional rows added in the first step
View(trla_merge %>%
filter(id == "2"))
#Results as expected -- 199 remain in original
trla_merge %>%
filter(id == "1") %>%
group_by(missing_AP) %>%
summarise(n())
#Overall, we get the number of missing APs we were expecting, but fewer because we filtered out pre-2014 for the unique trla_more rows
trla_merge %>%
group_by(missing_AP) %>%
summarise(n())
trla_merge2 <- trla_merge %>%
separate_rows(opstate.y, sep = ",") %>%
mutate(derived_opponent_state = case_when(is.na(opstate.x) ~ opstate.y,
TRUE ~ opstate.x)) %>%
select(c("intake_date.x", "derived_opponent_consolidated", "derived_opponent_state", "derived_opponent_city", "missing_AP", "count_AP_states.y", "derived_is_notemp")) %>%
filter(!derived_is_notemp & !missing_AP) %>%
select(-c("derived_is_notemp", "missing_AP"))
sum(trla_merge$count_AP_states.y, na.rm = TRUE)
trla_merge2 <- trla_merge %>%
separate_rows(opstate.y, sep = ",")
trla_merge2 <- trla_merge %>%
separate_rows(opstate.y, sep = ",")
View(trla_merge2)
trla_merge2 <- trla_merge %>%
if(derived_source == "trla_more"){
separate_rows(opstate.y, sep = ",")} %>%
mutate(derived_opponent_state = case_when(is.na(opstate.x) ~ opstate.y,
TRUE ~ opstate.x)) %>%
select(c("intake_date.x", "derived_opponent_consolidated", "derived_opponent_state", "derived_opponent_city", "missing_AP", "count_AP_states.y", "derived_is_notemp")) %>%
filter(!derived_is_notemp & !missing_AP) %>%
select(-c("derived_is_notemp", "missing_AP"))
trla_merge2 <- trla_merge %>%
if(derived_source2 == "trla_more"){
separate_rows(opstate.y, sep = ",")} %>%
mutate(derived_opponent_state = case_when(is.na(opstate.x) ~ opstate.y,
TRUE ~ opstate.x)) %>%
select(c("intake_date.x", "derived_opponent_consolidated", "derived_opponent_state", "derived_opponent_city", "missing_AP", "count_AP_states.y", "derived_is_notemp")) %>%
filter(!derived_is_notemp & !missing_AP) %>%
select(-c("derived_is_notemp", "missing_AP"))
