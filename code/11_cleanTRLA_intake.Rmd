---
title: "trla_cleaning"
author: "Rebecca Johnson"
date: "8/3/2021"
output: html_document
---


# Packages / imports

```{r}
library(dplyr)
library(stringr)
library(fastLink)
library(readr)
library(data.table)
library(readxl)
library(here)
library(lubridate)

## Path to data
RUN_FROM_CONSOLE = FALSE
if(RUN_FROM_CONSOLE){
  args <- commandArgs(TRUE)
  DATA_DIR = args[1]
} else{
  DATA_DIR = "~/Dropbox/qss20_finalproj_rawdata/summerwork"
}
```

# Load data

```{r warning=FALSE}
## orig data 
trla_orig = read_excel(sprintf("%s/raw/Adverse_Parties_FW_TRLA.xlsx", DATA_DIR)) %>%
    mutate(`Intake Date` = ymd(`Intake Date`),
           `Date Closed` = ymd(`Date Closed`))

## load second set of data
trla_more = read_excel(sprintf("%s/raw/master consol - redacted.xls", DATA_DIR))

```

```{r warning=FALSE}

##DROPBOX WORKAROUND -- DELETE LATER!
trla_orig <- read_excel("../../raw_workaround/Adverse_Parties_FW_TRLA.xlsx") %>%
    mutate(`Intake Date` = ymd(`Intake Date`),
           `Date Closed` = ymd(`Date Closed`))

##DROPBOX WORKAROUND -- DELETE LATER!
trla_more = read_excel("../../raw_workaround/master consol - redacted 2.xls")

#clean column names in original
clean_1 = gsub("\\s+", "_", tolower(trimws(colnames(trla_orig))))
clean_2 = gsub("\\#", "number", clean_1)
clean_3  = gsub("(?!\\_)[[:punct:]]", "", clean_2, perl = TRUE)
colnames(trla_orig) = clean_3

#Rename trla_more columns to match orig
trla_more <- trla_more %>%
  rename(case_number = fileno, legal_problem_code = problem, case_disposition = appsts, intake_date = date_intrv, derived_opponent_consolidated = opponent, date_closed = date_close)

```

TO DO:
Separate out multiple opponents in trla_more, plus multiple states?
Seeing if Dave can address

```{r}
sprintf("Columns in original data pull: %s", paste(colnames(trla_orig), collapse = ";")) 

sprintf("Columns in updated data pull: %s", paste(colnames(trla_more), collapse = ";")) 

sprintf("There are %s unique case numbers, %s unique case id/lead case ids, and %s rows in original dataset",
        length(unique(trla_orig$case_number)),
        length(unique(trla_orig$caseidlead_case_number)),
        nrow(trla_orig))

sprintf("There are %s unique case numbers and %s rows in original dataset",
        length(unique(trla_more$case_number)),
        nrow(trla_more))

```

```{r}
## focus on consolidating opponent columns

#If multiple are present you’d want to separate out.
#So, if ind AP is missing, use Lead AP. You have to decide if a “count” is tied to an individual client or to a group case.
#If Lead AP is missing, that is fine, use individual case AP.
#If both are present, you could separate out into two cases for the first occurrence? Or for each depending on how you’ve decided to count.

trla_orig = trla_orig %>%
      mutate(derived_opponent_consolidated = case_when(!is.na(adverse_party_organization) ~ adverse_party_organization,
                                               is.na(adverse_party_organization) & !is.na(lead_case_ap_organization) ~ lead_case_ap_organization,
                                               is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
                                              !is.na(adverse_party_name) ~ adverse_party_name,
                                              is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
                                              is.na(adverse_party_name) & !is.na(lead_case_ap_name) ~ lead_case_ap_name,
                                              TRUE ~ NA_character_),
             derived_opponent_source = case_when(!is.na(adverse_party_organization) ~ "AP org",
                                               is.na(adverse_party_organization) & !is.na(lead_case_ap_organization) ~ "Lead AP org",
                                               is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
                                              !is.na(adverse_party_name) ~ "AP name",
                                              is.na(adverse_party_organization) & is.na(lead_case_ap_organization) &
                                              is.na(adverse_party_name) & !is.na(lead_case_ap_name) ~ "Lead AP name",
                                              TRUE ~ "Missing all"),
             
             derived_is_notemp = case_when(grepl("Social Security Administration|Department of Labor|Workforce|Department|Dept|U.S. Immigration and Customs Enforcement|United States Customs and Border Protection|United States Environmental Protection Agency|United States Immigration and Naturalization Service|United States of America|Texas Attorney General|Texas Employment Commission|US Citizenship And Immigration Services|	
Texas Unemployment Commission|workforce", derived_opponent_consolidated) ~ TRUE,
                                      TRUE ~  FALSE)) 
```

TO DO:

Figure out hierarchical strategy here.

How many case numbers are shared between trla_orig with "Missing all" and trla_more?
How many will get filled in with the 'trla_more'?

Need to figure out if I can rowbind or if it's actually a join. Could be both.
- If case number matches across sets and opp is missing, sub 'more'
- If case number matches across sets and opp is present but different, add new row with 'more' info
- If case number matches across sets and opp is present and same, do nothing


```{r}

trla_more <- trla_more %>%
  mutate(missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE))

#Create flags for 'in more' & 'missing AP' in either or both
#Filter out earlier data

trla_orig2 <- trla_orig %>%
  group_by(case_number) %>%
  mutate(in_more = ifelse(case_number %in% trla_more$case_number, TRUE, FALSE)) %>%
  ungroup() %>%
  mutate(missing_AP = ifelse(is.na(derived_opponent_consolidated), TRUE, FALSE),

         AP_in_more = ifelse((in_more & !is.na(trla_more$derived_opponent_consolidated)), TRUE, FALSE),
         
         missing_in_both = ifelse((missing_AP & trla_more$missing_AP),TRUE, FALSE)) %>%
  
  filter(intake_date >= ymd("2014-01-01"))


#Filtering for cases in 2014 and greater leaves us with only 148 missing an adverse party in both datasets
View(trla_orig2 %>%
      group_by(missing_in_both) %>%
       summarise(n()))

#Checking for any illogical combinations
View(trla_orig2 %>%
      group_by(missing_in_both,AP_in_more, missing_AP, in_more) %>%
       summarise(n()))

#BEFORE any merges, count of missing
trla_orig2 %>%
      group_by(missing_AP) %>%
       summarise(n())

```


```{r}
#Follow proposed logic to join the datasets
trla_orig3 <- trla_orig2 %>%
  
#This does not work -- matches are weird and wrong!
  
  mutate(derived_opponent_consolidated = ifelse((is.na(derived_opponent_consolidated) & AP_in_more), 
                                                trla_more$derived_opponent_consolidated, 
                                                derived_opponent_consolidated),
         
         missing_AP = ifelse(is.na(derived_opponent_consolidated),TRUE,FALSE))


```


```{r}

## reasons for repeat:
## (1) different adverse parties (e.g., a grower and FLC)- example: case 01-105990 - address later when merging to jobs
## (2) missing addresses in one of the rows - example: 31807  address using group_by pre jobs merge (after cleaning adverse party field)

trla_orig = trla_orig %>%
        group_by(case_number) %>%
        mutate(is_repeated_casenum = ifelse(n() > 1, TRUE, FALSE)) %>%
        ungroup() 

```

```{r}
## create flag for cases with multiple case_numbers


```

```{r}
## look at all unique ones

View(trla_orig %>% 
       filter(!is.na(derived_opponent_consolidated)) %>% 
       group_by(derived_opponent_consolidated) %>% 
       summarise(count = n()) %>%
       arrange(desc(count)) %>% slice(1:100))

## for names, matching them to organizations based on other records with name
```